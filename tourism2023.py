# -*- coding: utf-8 -*-
"""tourism2023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c9osqXQgMiZ8_D0Q9645Ll-iQp6DdiXq
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# Load CSV files
tourist_df = pd.read_csv('/content/drive/MyDrive/colab_data/rancho/tourism2023.csv')

tourist_df.head()

"""**Data Cleaning**"""

# Checking for null values
null_values = tourist_df.isnull().sum()
print("Null values in each column:\n", null_values)

# Filling null values with column averages
tourist_df.fillna(tourist_df.mean(), inplace=True)

print(tourist_df.dtypes)

print(tourist_df.columns)

# Remove leading and trailing white spaces from column names
tourist_df.columns = [col.strip() for col in tourist_df.columns]

# Verify updated column names
print(tourist_df.columns)

tourist_df['year'] = pd.to_datetime(tourist_df['year'], format='%Y')

print(tourist_df.dtypes)

"""**Exploratory Data Analysis**"""

# Descriptive statistics
desc_stats = tourist_df.describe()
desc_stats

print(desc_stats)

# Time series analysis
time_series_data = tourist_df[['year', 'Total Arrivals']]
# Plotting time series data
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
plt.plot(time_series_data['year'], time_series_data['Total Arrivals'])
plt.xlabel('Year')
plt.ylabel('Total Arrivals')
plt.title('Total Arrivals Over Time')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Select columns highly related to tourism growth
columns_of_interest = [
    'Total Arrivals', 'EXCHANGE RATE', 'Travel', 'Passenger transport',  'GDP', 'Number of rooms', 'Number of establishments', 'Number of bed-places', 'Occupancy rate / rooms', 'Occupancy rate / bed-places', 'POPULATION'
]

tourist_df['GDP'] = tourist_df['GDP'].astype(str)
# print(tourist_df['GDP'].type)

# Plotting time series for selected columns
plt.figure(figsize=(12, 8))
for column in columns_of_interest:
    plt.plot(tourist_df['year'], tourist_df[column], label=column)

plt.xlabel('Year')
plt.ylabel('Values')
plt.title('Time Series Analysis of Factors Related to Tourism Growth')
plt.legend()
plt.grid(True)
plt.show()

"""Calculation of Growth Rates:"""

# Calculating Yearly Growth Rate for 'Total Arrivals' column
tourist_df['Yearly Growth Rate'] = tourist_df['Total Arrivals'].pct_change() * 100

# Displaying the computed yearly growth rate
print(tourist_df[['year', 'Total Arrivals', 'Yearly Growth Rate']])

# Plotting Time Series for 'Total Arrivals' and Yearly Growth Rate
plt.figure(figsize=(12, 8))

# Plot 'Total Arrivals' over time
plt.subplot(2, 1, 1)
plt.plot(tourist_df['year'], tourist_df['Total Arrivals'], label='Total Arrivals')
plt.xlabel('Year')
plt.ylabel('Total Arrivals')
plt.title('Total Arrivals Over Time')
plt.legend()
plt.grid(True)

# Plot 'Yearly Growth Rate' over time
plt.subplot(2, 1, 2)
plt.plot(tourist_df['year'], tourist_df['Yearly Growth Rate'], label='Yearly Growth Rate', color='orange')
plt.xlabel('Year')
plt.ylabel('Yearly Growth Rate (%)')
plt.title('Yearly Growth Rate of Total Arrivals Over Time')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

"""**Correlation Analysis:**"""

columns_for_correlation = [
    'Total Arrivals','Travel', 'Passenger transport', 'GDP',  'Number of rooms', 'Number of establishments', 'Number of bed-places', 'Occupancy rate / rooms', 'Occupancy rate / bed-places', 'POPULATION',
    'Yearly Growth Rate'
]

# Compute correlation matrix
correlation_matrix = tourist_df[columns_for_correlation].corr()

# Plotting the correlation matrix as a heatmap
import seaborn as sns
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Matrix of Tourism-related Variables and Yearly Growth Rate')
plt.show()

columns_for_correlation = [
    'Total Arrivals', 'Africa', 'Americas', 'Europe', 'Middle East', 'South Asia',
    'Total', 'Travel', 'Passenger transport', 'Number of establishments', 'GDP',
    'Yearly Growth Rate'
]

# Compute correlation matrix
correlation_matrix = tourist_df[columns_for_correlation].corr()

# Print correlation values with Yearly Growth Rate
correlation_with_growth_rate = correlation_matrix['Yearly Growth Rate'].sort_values(ascending=False)
print("Correlation with Yearly Growth Rate:")
print(correlation_with_growth_rate)

"""**Forecasting and model analysis:**"""

from statsmodels.tsa.arima.model import ARIMA

total_arrivals_series = tourist_df['Total Arrivals']

# Fit ARIMA model
model = ARIMA(total_arrivals_series, order=(1, 1, 1))  # Example order - adjust as needed
model_fit = model.fit()

# Forecast future values
forecast_steps = 5
forecast = model_fit.forecast(steps=forecast_steps)

# Display the forecasted values
print("Forecasted values for Total Arrivals:")
print(forecast)

from statsmodels.tsa.arima.model import ARIMA
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error


# Splitting the data into training and testing sets (80% train, 20% test)
train_size = int(len(total_arrivals_series) * 0.8)
train, test = total_arrivals_series[0:train_size], total_arrivals_series[train_size:]

# Fit ARIMA model to the training data
model = ARIMA(train, order=(1, 1, 1))
model_fit = model.fit()

# Forecasting future values on the test set
forecast_steps = len(test)
forecast = model_fit.forecast(steps=forecast_steps)

# Calculating MAE to evaluate the model's performance
mae = mean_absolute_error(test, forecast)
print("Mean Absolute Error (MAE):", mae)

# Visualizing actual vs predicted values
plt.figure(figsize=(10, 6))
plt.plot(test.index, test, label='Actual')
plt.plot(test.index, forecast, label='Predicted', color='red')
plt.xlabel('Date')
plt.ylabel

from sklearn.ensemble import RandomForestRegressor
import numpy as np

total_arrivals_series = tourist_df['Total Arrivals']

# Prepare features and target variable
X = total_arrivals_series.dropna().index.values
y = total_arrivals_series.dropna().values

# Initialize and fit the model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X.reshape(-1, 1), y)

# Forecast future values
future_steps = 5

# Get the last index value and create future indices
last_index = max(X)
future_indices = np.arange(last_index + 1, last_index + 1 + future_steps)
forecast_rf = rf_model.predict(future_indices.reshape(-1, 1))

# Display the forecasted values
print("RandomForestRegressor Forecasted values for Total Arrivals:")
print(forecast_rf)

# from sklearn.ensemble import RandomForestRegressor
# from sklearn.model_selection import train_test_split
# from sklearn.metrics import mean_absolute_error

# from sklearn.metrics import mean_squared_error, r2_score

# # Calculate Mean Absolute Error (MAE)
# mae_rf = mean_absolute_error(y_test, predictions_rf)
# print("RandomForestRegressor Mean Absolute Error (MAE):", mae_rf)

# # Calculate Mean Squared Error (MSE)
# mse_rf = mean_squared_error(y_test, predictions_rf)
# print("RandomForestRegressor Mean Squared Error (MSE):", mse_rf)

# # Calculate Root Mean Squared Error (RMSE)
# rmse_rf = mean_squared_error(y_test, predictions_rf, squared=False)
# print("RandomForestRegressor Root Mean Squared Error (RMSE):", rmse_rf)

# # Calculate R-squared (R²)
# r2_rf = r2_score(y_test, predictions_rf)
# print("RandomForestRegressor R-squared (R²):", r2_rf)

# # Visualize actual vs predicted values
# plt.figure(figsize=(10, 6))
# plt.plot(X_test, y_test, label='Actual')
# plt.plot(X_test, predictions_rf, label='Predicted', color='red')
# plt.xlabel('Index')
# plt.ylabel('Total Arrivals')
# plt.title('Actual vs Predicted Total Arrivals (RandomForestRegressor)')
# plt.legend()
# plt.grid(True)
# plt.show()
# # # Assuming 'total_arrivals_series' contains your 'Total Arrivals' time series data

# # # Splitting the data into training and testing sets (80% train, 20% test)
# # X = total_arrivals_series.dropna().index.values.reshape(-1, 1)
# # y = total_arrivals_series.dropna().values

# # X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# # # Initialize and fit the model
# # rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
# # rf_model.fit(X_train, y_train)

# # # Make predictions on the test set
# # predictions_rf = rf_model.predict(X_test)

# # # Calculate MAE to evaluate the model's performance
# # mae_rf = mean_absolute_error(y_test, predictions_rf)
# # print("RandomForestRegressor Mean Absolute Error (MAE):", mae_rf)


# # # from sklearn.metrics import mean_squared_error, r2_score
# # # import matplotlib.pyplot as plt

# # # Calculate Mean Squared Error (MSE)
# # mse_rf = mean_squared_error(y_test, predictions_rf)
# # print("RandomForestRegressor Mean Squared Error (MSE):", mse_rf)

# # # Calculate Root Mean Squared Error (RMSE)
# # rmse_rf = mean_squared_error(y_test, predictions_rf, squared=False)
# # print("RandomForestRegressor Root Mean Squared Error (RMSE):", rmse_rf)

# # # Calculate R-squared (R²)
# # r2_rf = r2_score(y_test, predictions_rf)
# # print("RandomForestRegressor R-squared (R²):", r2_rf)

# # # Visualize actual vs predicted values
# # plt.figure(figsize=(10, 6))
# # plt.scatter(y_test, predictions_rf, alpha=0.5)
# # plt.xlabel('Actual Total Arrivals')
# # plt.ylabel('Predicted Total Arrivals')
# # plt.title('Actual vs Predicted Total Arrivals (RandomForestRegressor)')
# # plt.grid(True)
# # plt.show()





# # from sklearn.metrics import mean_squared_error, r2_score
# # import matplotlib.pyplot as plt

# # # Calculate Mean Squared Error (MSE)
# # mse_rf = mean_squared_error(y_test, predictions_rf)
# # print("RandomForestRegressor Mean Squared Error (MSE):", mse_rf)

# # # Calculate Root Mean Squared Error (RMSE)
# # rmse_rf = mean_squared_error(y_test, predictions_rf, squared=False)
# # print("RandomForestRegressor Root Mean Squared Error (RMSE):", rmse_rf)

# # # Calculate R-squared (R²)
# # r2_rf = r2_score(y_test, predictions_rf)
# # print("RandomForestRegressor R-squared (R²):", r2_rf)

# # # Visualize actual vs predicted values
# # plt.figure(figsize=(10, 6))
# # plt.scatter(y_test, predictions_rf, alpha=0.5)
# # plt.xlabel('Actual Total Arrivals')
# # plt.ylabel('Predicted Total Arrivals')
# # plt.title('Actual vs Predicted Total Arrivals (RandomForestRegressor)')
# # plt.grid(True)
# # plt.show()

# # from sklearn.metrics import mean_squared_error, r2_score

# # # Calculate Mean Absolute Error (MAE)
# # mae_rf = mean_absolute_error(y_test, predictions_rf)
# # print("RandomForestRegressor Mean Absolute Error (MAE):", mae_rf)

# # # Calculate Mean Squared Error (MSE)
# # mse_rf = mean_squared_error(y_test, predictions_rf)
# # print("RandomForestRegressor Mean Squared Error (MSE):", mse_rf)

# # # Calculate Root Mean Squared Error (RMSE)
# # rmse_rf = mean_squared_error(y_test, predictions_rf, squared=False)
# # print("RandomForestRegressor Root Mean Squared Error (RMSE):", rmse_rf)

# # # Calculate R-squared (R²)
# # r2_rf = r2_score(y_test, predictions_rf)
# # print("RandomForestRegressor R-squared (R²):", r2_rf)

# # # Visualize actual vs predicted values
# # plt.figure(figsize=(10, 6))
# # plt.plot(X_test, y_test, label='Actual')
# # plt.plot(X_test, predictions_rf, label='Predicted', color='red')
# # plt.xlabel('Index')
# # plt.ylabel('Total Arrivals')
# # plt.title('Actual vs Predicted Total Arrivals (RandomForestRegressor)')
# # plt.legend()
# # plt.grid(True)
# # plt.show()

from sklearn.linear_model import LinearRegression

# Prepare features and target variable
X = total_arrivals_series.dropna().index.values.reshape(-1, 1)
y = total_arrivals_series.dropna().values

# Initialize and fit the Linear Regression model
lr_model = LinearRegression()
lr_model.fit(X, y)

# Forecast future values
forecast_lr = lr_model.predict(np.array(future_indices).reshape(-1, 1))

# Display the forecasted values
print("LinearRegression Forecasted values for Total Arrivals:")
print(forecast_lr)

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Assuming 'total_arrivals_series' contains your 'Total Arrivals' time series data

# Prepare features and target variable
X = total_arrivals_series.dropna().index.values.reshape(-1, 1)
y = total_arrivals_series.dropna().values

# Split the data into training and testing sets (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and fit the Linear Regression model
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)

# Make predictions on the test set
predictions_lr = lr_model.predict(X_test)

# Calculate Mean Absolute Error (MAE)
mae_lr = mean_absolute_error(y_test, predictions_lr)
print("Linear Regression Mean Absolute Error (MAE):", mae_lr)

# Calculate Mean Squared Error (MSE)
mse_lr = mean_squared_error(y_test, predictions_lr)
print("Linear Regression Mean Squared Error (MSE):", mse_lr)

# Calculate Root Mean Squared Error (RMSE)
rmse_lr = mean_squared_error(y_test, predictions_lr, squared=False)
print("Linear Regression Root Mean Squared Error (RMSE):", rmse_lr)

# Calculate R-squared (R²)
r2_lr = r2_score(y_test, predictions_lr)
print("Linear Regression R-squared (R²):", r2_lr)

# Forecast future values
forecast_lr = lr_model.predict(np.array(future_indices).reshape(-1, 1))
print("Linear Regression Forecasted values for Total Arrivals:")
print(forecast_lr)


plt.figure(figsize=(10, 6))
plt.plot(X_test, y_test, label='Actual')
plt.plot(X_test, predictions_lr, label='Predicted', color='red')
plt.xlabel('Index')
plt.ylabel('Total Arrivals')
plt.title('Actual vs Predicted Total Arrivals (Linear Regression)')
plt.legend()
plt.grid(True)
plt.show()

from sklearn.svm import SVR
from sklearn.preprocessing import StandardScaler

# Scale the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Initialize and fit the SVR model
svr_model = SVR(kernel='rbf')  # Example kernel - adjust as needed
svr_model.fit(X_scaled, y)

# Scale the future indices and forecast future values
future_indices_scaled = scaler.transform(np.array(future_indices).reshape(-1, 1))
forecast_svr = svr_model.predict(np.array(future_indices_scaled).reshape(-1, 1))

# Display the forecasted values
print("SVR Forecasted values for Total Arrivals:")
print(forecast_svr)

from sklearn.model_selection import train_test_split
from sklearn.svm import SVR
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler
import numpy as np

# Assuming 'X' and 'y' are your features and target variable
# Scale the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Split the data into training and testing sets (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Initialize and fit the SVR model
svr_model = SVR(kernel='rbf')  # Example kernel - adjust as needed
svr_model.fit(X_train, y_train)

# Make predictions on the test set
predictions_svr = svr_model.predict(X_test)

# Calculate Mean Absolute Error (MAE)
mae_svr = mean_absolute_error(y_test, predictions_svr)
print("SVR Mean Absolute Error (MAE):", mae_svr)

# Calculate Mean Squared Error (MSE)
mse_svr = mean_squared_error(y_test, predictions_svr)
print("SVR Mean Squared Error (MSE):", mse_svr)

# Calculate Root Mean Squared Error (RMSE)
rmse_svr = mean_squared_error(y_test, predictions_svr, squared=False)
print("SVR Root Mean Squared Error (RMSE):", rmse_svr)

# Calculate R-squared (R²)
r2_svr = r2_score(y_test, predictions_svr)
print("SVR R-squared (R²):", r2_svr)

# Forecast future values
future_indices_scaled = scaler.transform(np.array(future_indices).reshape(-1, 1))
forecast_svr = svr_model.predict(future_indices_scaled)
print("SVR Forecasted values for Total Arrivals:")
print(forecast_svr)

plt.figure(figsize=(10, 6))
plt.plot(y_test, label='Actual')
plt.plot(predictions_svr, label='Predicted', color='red')
plt.xlabel('Index')
plt.ylabel('Total Arrivals')
plt.title('Actual vs Predicted Total Arrivals (SVR)')
plt.legend()
plt.grid(True)
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense
from keras.callbacks import EarlyStopping
import numpy as np

# Extract the 'Total Arrivals' column for forecasting
total_arrivals_series = tourist_df['Total Arrivals']

# Normalize the data using MinMaxScaler
scaler = MinMaxScaler()
total_arrivals_normalized = scaler.fit_transform(total_arrivals_series.values.reshape(-1, 1))

# Prepare the data for LSTM
time_steps = 3  # Number of time steps for LSTM
X, y = [], []

for i in range(len(total_arrivals_normalized) - time_steps):
    X.append(total_arrivals_normalized[i:(i + time_steps), 0])
    y.append(total_arrivals_normalized[i + time_steps, 0])

X, y = np.array(X), np.array(y)

# Reshape data for LSTM input [samples, time steps, features]
X = X.reshape((X.shape[0], X.shape[1], 1))

# Split the data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Define and compile the LSTM model
lstm_model = Sequential()
lstm_model.add(LSTM(units=50, activation='relu', input_shape=(X.shape[1], 1)))
lstm_model.add(Dense(1))
lstm_model.compile(optimizer='adam', loss='mse')

# Fit the LSTM model
lstm_model.fit(X_train, y_train, epochs=100, batch_size=32, verbose=1, validation_data=(X_test, y_test))

# Forecast future values
future_time_steps = 5
future_X = total_arrivals_normalized[-time_steps:].reshape((1, time_steps, 1))

forecast_lstm_normalized = []

for i in range(future_time_steps):
    predicted_value = lstm_model.predict(future_X)[0, 0]
    forecast_lstm_normalized.append(predicted_value)
    future_X = np.append(future_X[:, 1:, :], [[[predicted_value]]], axis=1)

# Inverse transform the forecasted values to original scale
forecast_lstm = scaler.inverse_transform(np.array(forecast_lstm_normalized).reshape(-1, 1))

# Display the forecasted values
print("LSTM Forecasted values for Total Arrivals:")
print(forecast_lstm.flatten())

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense
from keras.callbacks import EarlyStopping
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import matplotlib.pyplot as plt
import numpy as np

# Extract the 'Total Arrivals' column for forecasting
total_arrivals_series = tourist_df['Total Arrivals']

# Normalize the data using MinMaxScaler
scaler = MinMaxScaler()
total_arrivals_normalized = scaler.fit_transform(total_arrivals_series.values.reshape(-1, 1))

# Prepare the data for LSTM
time_steps = 3  # Number of time steps for LSTM
X, y = [], []

for i in range(len(total_arrivals_normalized) - time_steps):
    X.append(total_arrivals_normalized[i:(i + time_steps), 0])
    y.append(total_arrivals_normalized[i + time_steps, 0])

X, y = np.array(X), np.array(y)

# Reshape data for LSTM input [samples, time steps, features]
X = X.reshape((X.shape[0], X.shape[1], 1))

# Split the data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Define and compile the LSTM model
lstm_model = Sequential()
lstm_model.add(LSTM(units=50, activation='relu', input_shape=(X.shape[1], 1)))
lstm_model.add(Dense(1))
lstm_model.compile(optimizer='adam', loss='mse')

# Fit the LSTM model
lstm_model.fit(X_train, y_train, epochs=100, batch_size=32, verbose=1, validation_data=(X_test, y_test))

# Predictions on the test set
y_pred = lstm_model.predict(X_test)

# Inverse transform the predictions to original scale
y_pred_inverse = scaler.inverse_transform(y_pred)
y_test_inverse = scaler.inverse_transform(y_test.reshape(-1, 1))

# Calculate Mean Absolute Error (MAE)
mae_lstm = mean_absolute_error(y_test_inverse, y_pred_inverse)
print("LSTM Mean Absolute Error (MAE):", mae_lstm)

# Calculate Mean Squared Error (MSE)
mse_lstm = mean_squared_error(y_test_inverse, y_pred_inverse)
print("LSTM Mean Squared Error (MSE):", mse_lstm)

# Calculate Root Mean Squared Error (RMSE)
rmse_lstm = mean_squared_error(y_test_inverse, y_pred_inverse, squared=False)
print("LSTM Root Mean Squared Error (RMSE):", rmse_lstm)

# Calculate R-squared (R²)
r2_lstm = r2_score(y_test_inverse, y_pred_inverse)
print("LSTM R-squared (R²):", r2_lstm)

# Visualize actual vs predicted values
plt.figure(figsize=(10, 6))
plt.plot(y_test_inverse, label='Actual')
plt.plot(y_pred_inverse, label='Predicted', color='red')
plt.xlabel('Index')
plt.ylabel('Total Arrivals')
plt.title('Actual vs Predicted Total Arrivals (LSTM)')
plt.legend()
plt.grid(True)
plt.show()

# Calculate the average of predictions from different models
hybrid_forecast = (
    forecast_rf + forecast_lr + forecast_svr.flatten() + forecast_lstm.flatten()
) / 5

print("Hybrid Model Forecasted values for Total Arrivals:")
print(hybrid_forecast)

"""**Exporting Model**"""

import joblib

# Save the model to a file
joblib.dump(hybrid_forecaster, 'model.pkl')